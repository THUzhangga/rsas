# cython: profile=True
# -*- coding: utf-8 -*-
"""
.. module:: rsas
   :platform: Unix, Windows
   :synopsis: Time-variable transport using storage selection (SAS) functions

.. moduleauthor:: Ciaran J. Harman
"""

from __future__ import division
import cython
import numpy as np
cimport numpy as np
from warnings import warn
dtype = np.float64
ctypedef np.float64_t dtype_t
ctypedef np.int_t inttype_t
ctypedef np.long_t longtype_t
cdef inline np.float64_t float64_max(np.float64_t a, np.float64_t b): return a if a >= b else b
cdef inline np.float64_t float64_min(np.float64_t a, np.float64_t b): return a if a <= b else b
from _rsas_functions import rSASFunctionClass
from scipy.special import gamma as gamma_function
from scipy.special import gammainc
from scipy.special import erfc
from scipy.interpolate import interp1d
from scipy.optimize import fmin, minimize_scalar, fsolve
import time
#import rsas._util

# for debugging
debug = True
def _verbose(statement):
    """Prints debuging messages if rsas.debug==True

    """
    if debug:
        print statement

def solve(J, Q, rSAS_fun, mode='RK4', ST_init = None, dt = 1, n_substeps = 1,
          full_outputs=True, MS_init = None, C_J=None, alpha=None, krate=None,  C_old=None):
    """Solve the rSAS model for given fluxes

    Args:
        J : n x 1 float64 ndarray
            Timestep-averaged inflow timeseries
        Q : n x 2 float64 ndarray or list of n x 1 float64 ndarray
            Timestep-averaged outflow timeseries. Must have same units and length as J.
            For multiple outflows, each column represents one outflow
        rSAS_fun : rSASFunctionClass or list of rSASFunctionClass generated by rsas.create_function
            The number of rSASFunctionClass in this list must be the same as the
            number of columns in Q if Q is an ndarray, or elements in Q if it is a list.

    Kwargs:
        mode : 'age', 'time', 'RK4' (default)
            Numerical solution step order. 'mode' refers to which variable is in the
            outer loop of the numerical solution

            ``mode='age'``
                This is the original implementation used to generate the results in the paper.
                It is now deprecated in favor of the mode='time' option. It lacks the
                memory-saving "full_outputs=False" option. There is no option to calculate
                output concentration timeseries inline. The calculated transit time
                distributions must convolved with an input concentration timeseries after the code has
                completed.
            ``mode='time'``
                Slower, but easier to understand and build on than the 'age' mode.
                Memory savings come with the option to determine output concentrations
                from a given input concentration progressively, and not retain the full
                age-ranked storage and transit time distributions in memory (set
                full_outputs=False to take advantage of this).
            ``mode='RK4'``
                Faster and more accurate than 'age' or 'time'. Can calculate concentrations
                progressively, and need not retain large matricies in memory (if
                full_outputs=False)
        ST_init : m x 1 float64 ndarray
            Initial condition for the age-ranked storage. The length of ST_init
            determines the maximum age calculated. The first entry must be 0
            (corresponding to zero age). To calculate transit time dsitributions up
            to N timesteps in age, ST_init should have length m = M + 1. The default
            initial condition is ST_init=np.zeros(len(J) + 1).
        dt : float (default 1)
            Timestep, assuming same units as J
        n_substeps : int (default 1)
            If n_substeps>1, the timesteps are subdivided to allow a more accurate
            solution. Default is 1, which is also the value used in Harman (2015)
        inc_tol : float (default 1E-10)
            Tolerance for the iterative solution for the ST matrix
        max_iter : int (default 25)
            Maximum number of iterations to converge on a consistent solution.
        full_outputs : bool (default True)
            Option to return the full state variables array ST the cumulative
            transit time distributions PQ1, PQ2, and other variables
        MS_init : m x p float64 ndarray
            Initial condition for the age-ranked solute mass. Must be the
            same length as ST_init
        C_J : n x p float64 ndarray (default None)
            Optional timeseries of inflow concentrations to convolved
            with the computed transit time distribution for the first flux in Q
        C_old : p x 1 float64 ndarray (default None)
            Optional concentration of the 'unobserved fraction' of Q (from inflows
            prior to the start of the simulation) for correcting C_Q. If ST_init is not given
            or set to all zeros, the unobserved fraction will be assumed to lie on the
            diagonal of the PQ matrix. Otherwise it will be assumed to be the bottom row.



    Returns:
        A dict with the following keys:
            'ST' : numpy float64 2D array
                Array of age-ranked storage for all ages and times. (full_outputs=True only)
            'PQ' : numpy float64 2D array
                List of time-varying cumulative transit time distributions. (full_outputs=True only)
            'Qout' : numpy float64 2D array
                List of age-based outflow timeseries. Useful for visualization. (full_outputs=True only)
            'theta' : numpy float64 2D array
                List of partial partition functions for each outflux. Keeps track of the
                fraction of inputs that leave by each flux. This is needed to do
                transport with evapoconcentration. (full_outputs=True only)
            'thetaS' : numpy float64 2D array
                Storage partial partition function fr each outflux. Keeps track of the
                fraction of inputs that remain in storage. This is needed to do
                transport with evapoconcentration. (full_outputs=True only)
            'MassBalance' : numpy float64 2D array
                Should always be within tolerances of zero, unless something is very
                wrong. (full_outputs=True only)
            'C_Q' : list of numpy float64 1D array
                If C_J is supplied, C_Q is the timeseries of outflow concentration
                in Q1. (mode='time' only)

    For each of the arrays in the full outputs each row represents an age, and each
    column is a timestep. For N timesteps and M ages, ST will have dimensions
    (M+1) x (N+1), with the first row representing age T = 0 and the first
    column derived from the initial condition.
    """
    # This function just does input checking
    # then calls the private implementation functions defined below
    if type(J) is not np.ndarray or J.ndim!=1:
        raise TypeError('J must be a 1-D numpy array')
    if (type(Q) is not np.ndarray) or (Q.ndim>2) or (Q.shape[0]!=len(J)):
        raise TypeError('Q must be a 1 or 2-D numpy array with a column for each outflow\nor a list of two 1-D numpy arrays (like ''[Q1, Q2]'')\nand each must be the same size as J')
    elif Q.ndim==1:
            Q=np.c_[Q]
    if ST_init is not None:
        if type(ST_init) is not np.ndarray or ST_init.ndim!=1:
            raise TypeError('ST_init must be a 1-D numpy array')
    if not type(rSAS_fun) is list:
        rSAS_fun = [rSAS_fun]
    if Q.shape[1]!=len(rSAS_fun):
        raise TypeError('Each rSAS function must have a corresponding outflow in Q. Numbers don''t match')
    for fun in rSAS_fun:
        fun_methods = [method for method in dir(fun) if callable(getattr(fun, method))]
        if not ('cdf_all' in fun_methods and 'cdf_i' in fun_methods):
            raise TypeError('Each rSAS function must have methods rSAS_fun.cdf_all and rSAS_fun.cdf_i')
    if type(full_outputs) is not bool:
        raise TypeError('full_outputs must be a boolean (True/False)')
    if C_J is not None and ((type(C_J) is not np.ndarray) or (C_J.ndim>2) or (C_J.shape[0]!=len(J))):
        raise TypeError('C_J must be a 1 or 2-D numpy array with a first dimension the same length as J')
    elif C_J.ndim==1:
            C_J=np.c_[C_J]
    if alpha is not None:
        if type(alpha) is not np.ndarray:
            alpha = np.array(alpha)
        if alpha.ndim==2:
            alpha = np.tile(alpha,(len(J),1,1))
        if (alpha.shape[2]!=C_J.shape[1]) and (alpha.shape[1]!=Q.shape[1]):
            raise TypeError("alpha array dimensions don't match other inputs")
    else:
        alpha = np.ones((len(J), Q.shape[1], C_J.shape[1]))
    if C_old is not None:
        if type(C_old) is not np.ndarray:
            C_old = np.array(C_old)
        if len(C_old)!=C_J.shape[1]:
            raise TypeError('C_old must have the same number of entries as C_J has columns')
    if dt is not None:
        dt = np.float64(dt)
    if n_substeps is not None:
        n_substeps = np.int(n_substeps)
    if full_outputs==False and C_J is None:
        warn('No output will be generated! Are you sure you mean to do this?')
    # Run implemented solvers
    _verbose('Running')
    if mode=='age':
        warn('mode age is deprecated, switching to RK4')
        mode='RK4'
    if mode=='time':
        warn('mode time is deprecated, switching to RK4')
        mode='RK4'
    if mode=='RK4':
        result = _solve_RK4(J, Q, rSAS_fun, ST_init=ST_init,
                            dt=dt, n_substeps=n_substeps,
                            full_outputs=full_outputs,
                            MS_init=MS_init, C_J=C_J, alpha=alpha, krate=krate, C_old=C_old)
    else:
        raise TypeError('Incorrect solution mode.')
    return result


@cython.boundscheck(False)
@cython.wraparound(False)
def _solve_RK4(np.ndarray[dtype_t, ndim=1] J,
        np.ndarray[dtype_t, ndim=2] Q,
        rSAS_fun,
        np.ndarray[dtype_t, ndim=1] ST_init = None,
        dtype_t dt = 1,
        int n_substeps = 1,
        full_outputs = True,
        np.ndarray[dtype_t, ndim=2] MS_init = None,
        np.ndarray[dtype_t, ndim=2] C_J = None,
        np.ndarray[dtype_t, ndim=3] alpha = None,
        np.ndarray[dtype_t, ndim=2] krate = None,
        np.ndarray[dtype_t, ndim=1] C_old = None):
    """rSAS model, Runge-Kutta method

    See the docstring for rsas.solve for more information
    """
    # Initialization
    # Define some variables
    cdef int k, i, j, n, timeseries_length, num_inputs, max_age
    cdef int numflux
    cdef np.float64_t start_time, h
    cdef np.ndarray[dtype_t, ndim=1] STp, STn, STt, dSTt
    cdef np.ndarray[dtype_t, ndim=2] mSp, mSn, mSt
    cdef np.ndarray[dtype_t, ndim=2] PQ1, PQ2, PQ3, PQ4, PQn, dPQt
    cdef np.ndarray[dtype_t, ndim=2] ST, WaterBalance
    cdef np.ndarray[dtype_t, ndim=3] MS, SoluteBalance
    cdef np.ndarray[dtype_t, ndim=3] mQ1, mQ2, mQ3, mQ4, cQn, mQn
    cdef np.ndarray[dtype_t, ndim=3] PQ
    cdef np.ndarray[dtype_t, ndim=4] MQ
    cdef np.ndarray[dtype_t, ndim=3] C_Q
    numflux = Q.shape[1]
    # Some lengths
    timeseries_length = len(J)
    max_age = len(ST_init) - 1
    M = max_age * n_substeps
    h = dt / n_substeps
    _verbose('...initializing arrays...')
    if C_J is not None:
        numsol = C_J.shape[1]
        C_Q = np.zeros((timeseries_length, numflux, numsol), dtype=np.float64)
    else:
        numsol = 0
        C_Q = None
    # Create arrays to hold intermediate solutions
    STn = np.zeros(M+1, dtype=np.float64)
    STp = np.zeros(M+1, dtype=np.float64)
    STt = np.zeros(M+1, dtype=np.float64)
    PQ1 = np.zeros((M+1, numflux), dtype=np.float64)
    PQ2 = np.zeros((M+1, numflux), dtype=np.float64)
    PQ3 = np.zeros((M+1, numflux), dtype=np.float64)
    PQ4 = np.zeros((M+1, numflux), dtype=np.float64)
    PQn = np.zeros((M+1, numflux), dtype=np.float64)
    dSTt = np.zeros((M), dtype=np.float64)
    dPQt = np.zeros((M, numflux), dtype=np.float64)
    mQ1 = np.zeros((M, numflux, numsol), dtype=np.float64)
    mQ2 = np.zeros((M, numflux, numsol), dtype=np.float64)
    mQ3 = np.zeros((M, numflux, numsol), dtype=np.float64)
    mQ4 = np.zeros((M, numflux, numsol), dtype=np.float64)
    cQn = np.zeros((M, numflux, numsol), dtype=np.float64)
    mQn = np.zeros((M, numflux, numsol), dtype=np.float64)
    mSp = np.zeros((M, numsol), dtype=np.float64)
    mSn = np.zeros((M, numsol), dtype=np.float64)
    mSt = np.zeros((M, numsol), dtype=np.float64)
    # Create arrays to hold the state variables if they are to be outputted
    if full_outputs:
        ST = np.zeros((max_age + 1, timeseries_length + 1), dtype=np.float64)
        WaterBalance = np.zeros((max_age, timeseries_length), dtype=np.float64)
        PQ = np.zeros((max_age + 1, timeseries_length + 1, numflux), dtype=np.float64)
        if numsol>0:
            MS = np.zeros((max_age + 1, timeseries_length + 1, numsol), dtype=np.float64)
            MQ = np.zeros((max_age + 1, timeseries_length + 1, numflux, numsol), dtype=np.float64)
            SoluteBalance = np.zeros((max_age, timeseries_length, numsol), dtype=np.float64)
        else:
            MS, MQ, SoluteBalance = None
    else:
        ST, WaterBalance, PQ, MS, MQ, SoluteBalance = None, None, None, None, None, None
    _verbose('done')
    # Now we solve the governing equation
    # Set up initial and boundary conditions
    if ST_init is not None:
        STn[1:] = np.cumsum(np.diff(ST_init).repeat(n_substeps, axis=0))/n_substeps
        PQn[:] = np.c_[[rSAS_fun[q].cdf_i(STn, 0) for q in range(numflux)]].T
    dSTt[:] = np.diff(STn)
    if MS_init is not None:
        mSn[:] = np.diff(MS_init, axis=0).repeat(n_substeps, axis=0)/n_substeps
    if full_outputs:
        ST[:,0] = STn[0:M+1:n_substeps]
        PQ[:,0,:] = PQn[0:M+1:n_substeps, :]
        if numsol>0:
            MS[:,0,:] = np.r_[np.zeros((1, numsol)), np.cumsum(mSn, axis=0)][0:M+1:n_substeps]
    start_time = time.clock()
    _verbose('...solving...')
    # Primary solution loop over time t
    for i in range(timeseries_length):
    # Loop over substeps
        for k in range(n_substeps):
            STn, STp = STp, STn
            dSTt = np.roll(dSTt,1)
            dSTt[0] = h * J[i]
            if numsol>0:
                mSn, mSp = mSp, mSn
                mSp = np.roll(mSp,1)
                mSp[0,:] = 0.
            #_verbose('# K1')
            for q in range(numflux):
                PQ1[:,q] = rSAS_fun[q].cdf_i(STp, i)
            dPQt[1:,:] = np.diff(PQ1[0:M,:], axis=0)
            dPQt[0,:] = PQ1[0,:]
            for q in range(numflux):
                for s in range(numsol):
                    mQ1[:,q,s] = np.where(dSTt>0, mSp[:,s] * alpha[i,q,s] * Q[i,q] * dPQt[:,q] / dSTt, 0.)
            STt[:] = STp + (J[i] - np.dot(Q[i,:], PQ1.T)) * h/2
            for s in range(numsol):
                mSt[:,s] = mSp[:,s] - np.sum(mQ1[:,:,s], axis=1) * h/2
                mSt[0,s] += J[i] * C_J[i,s] * h/2
            #_verbose('# K2')
            for q in range(numflux):
                PQ2[:,q] = rSAS_fun[q].cdf_i(STt, i)
            dSTt[1:] = np.diff(STt[0:M], axis=0)
            dSTt[0] = STt[0]
            dPQt[1:,:] = np.diff(PQ2[0:M,:], axis=0)
            dPQt[0,:] = PQ2[0,:]
            for q in range(numflux):
                for s in range(numsol):
                    mQ2[:,q,s] = np.where(dSTt>0, mSt[:,s] * alpha[i,q,s] * Q[i,q] * dPQt[:,q] / dSTt, 0.)
            STt[:] = STp + (J[i] - np.dot(Q[i,:],PQ2.T)) * h/2
            for s in range(numsol):
                mSt[:,s] = mSp[:,s] - np.sum(mQ2[:,:,s], axis=1) * h/2
                mSt[0,s] += J[i] * C_J[i,s] * h/2
            #_verbose('# K3')
            for q in range(numflux):
                PQ3[:,q] = rSAS_fun[q].cdf_i(STt, i)
            dSTt[1:] = np.diff(STt[0:M], axis=0)
            dSTt[0] = STt[0]
            dPQt[1:,:] = np.diff(PQ3[0:M,:], axis=0)
            dPQt[0,:] = PQ2[0,:]
            for q in range(numflux):
                for s in range(numsol):
                    mQ3[:,q,s] = np.where(dSTt>0, mSt[:,s] * alpha[i,q,s] * Q[i,q] * dPQt[:,q] / dSTt, 0.)
            STt[:] = STp + (J[i] - np.dot(Q[i,:],PQ3.T)) * h
            for s in range(numsol):
                mSt[:,s] = mSp[:,s] - np.sum(mQ3[:,:,s], axis=1) * h
                mSt[0,s] += J[i] * C_J[i,s] * h
            #_verbose('# K4')
            for q in range(numflux):
                PQ4[:,q] = rSAS_fun[q].cdf_i(STt, i)
            dSTt[1:] = np.diff(STt[0:M], axis=0)
            dSTt[0] = STt[0]
            dPQt[1:,:] = np.diff(PQ4[0:M,:], axis=0)
            dPQt[0,:] = PQ2[0,:]
            for q in range(numflux):
                for s in range(numsol):
                    mQ4[:,q,s] = np.where(dSTt>0, mSt[:,s] * alpha[i,q,s] * Q[i,q] * dPQt[:,q] / dSTt, 0.)
            #_verbose(' Step')
            PQn[1:M+1] = (PQ1 + 2*PQ2 + 2*PQ3 + PQ4)[:M] / 6.
            STn[1:M+1] = STp[0:M] + h * (J[i] - np.dot(Q[i,:], PQn[1:M+1,:].T))
            dSTt = np.diff(STn, axis=0)
            dPQt = np.diff(PQn, axis=0)
            mQn = (mQ1 + 2*mQ2 + 2*mQ3 + mQ4) / 6.
            for s in range(numsol):
                mSn[:,s] = mSp[:,s]
                mSn[0,s]+= J[i] * C_J[i,s] * h
                for q in range(numflux):
                    cQn[:,q,s] = np.where(Q[i,q] * dPQt[:,q]>0, mQn[:,q,s] / (Q[i,q] * dPQt[:,q]), 0.)
                    mSn[:,s] += - mQn[:,q,s] * h
                    C_Q[i,q,s] += np.sum(cQn[:,q,s] * dPQt[:,q], axis=0) / n_substeps
            mSn[:] = np.maximum(0., mSn)
        _verbose('# Store the result, if needed')
        if full_outputs:
                ST[:max_age+1, i+1] = STn[:M+1:n_substeps]
                PQ[:max_age+1, i+1, :] = PQn[:M+1:n_substeps, :]
                WaterBalance[1:max_age, i] = np.diff(ST[0:max_age, i])-np.diff(ST[1:max_age+1, i+1]) - dt * np.dot(Q[i,:], np.diff(PQ[1:,i,:],axis=0).T)
                WaterBalance[0, i] = J[i] * dt - ST[0, i+1] - dt * np.dot(Q[i,:], PQ[1,i,:] - PQ[0,i,:])
                if numsol>0:
                    MS[:max_age+1, i+1, :] = np.r_[np.zeros((1,numsol)), np.cumsum(mSn, axis=0)][:M+1:n_substeps]
                    MQ[:max_age+1, i+1, :, :] = np.r_[np.zeros((1, numflux, numsol)), np.cumsum(mQn, axis=0)][:M+1:n_substeps, :, :]
                    for s in range(numsol):
                        SoluteBalance[1:max_age,i,s] = (np.diff(MS[0:max_age,i,s], axis=0) - np.diff(MS[1:max_age+1,i+1,s], axis=0)
                                                        - dt * np.sum(np.diff(MQ[1:,i,:,s], axis=0), axis=1))
                        SoluteBalance[0,i,s] = C_J[i,s] * J[i] * dt - MS[0,i+1,s] - dt * np.sum(MQ[1,i+1,:,s] - MQ[0,i+1,:,s])
        if np.mod(i+1,1000)==0:
            _verbose('...done ' + str(i+1) + ' of ' + str(max_age) + ' in ' + str(time.clock() - start_time) + ' seconds')
        result = {'ST':ST, 'PQ':PQ, 'WaterBalance':WaterBalance, 'MS':MS, 'MQ':MQ, 'C_Q':C_Q, 'SoluteBalance':SoluteBalance}
    return result
