<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Documentation of the rsas library &mdash; rsas 0.1.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="rsas 0.1.1 documentation" href="#" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">rsas 0.1.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="documentation-of-the-rsas-library">
<h1>Documentation of the rsas library<a class="headerlink" href="#documentation-of-the-rsas-library" title="Permalink to this headline">¶</a></h1>
<p>This library allows you to model transport through arbitrary control volumes using
rank StorAge Selection (rSAS) functions.</p>
</div>
<div class="section" id="getting-started">
<h1>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h1>
<div class="section" id="before-you-install">
<h2>Before you install<a class="headerlink" href="#before-you-install" title="Permalink to this headline">¶</a></h2>
<p>rsas depends on the Python libraries numpy, scipy, and cython, and the example
codes use pandas to wrangle the timeseries data. These must all be installed.
The Anaconda package (<a class="reference external" href="https://store.continuum.io/cshop/anaconda/">https://store.continuum.io/cshop/anaconda/</a>) contains all
the needed pieces, and is an easy way to get started. Install it before you
install rsas.</p>
</div>
<div class="section" id="getting-rsas">
<h2>Getting rsas<a class="headerlink" href="#getting-rsas" title="Permalink to this headline">¶</a></h2>
<p>rsas is available from github: <a class="reference external" href="https://github.com/charman2/rsas">https://github.com/charman2/rsas</a></p>
<p>The repository is currently private, so only collaborators can access it. Please
do not share the source code before I release it.</p>
<p>The code can be downloaded zipped, but a git clone is recommended so updates
can be provided as they are developed.</p>
</div>
<div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>The main part of the code is written in Cython to allow fast execution. Before
you use rsas you must comile and install it. Open a terminal in the rsas directory
and run:</p>
<p>&gt; python setup.py install</p>
<p>It may take a few minutes. You may get warning messages, all of which can be ignored.
Error messages cannot though, and will prevent the compilation from completion.</p>
<p>Once the code has compiled successfully you don&#8217;t need to do it again
unless this code is changed.</p>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>Example uses of rsas are available in the ./examples directory. These should
run right out of the box.</p>
<div class="section" id="simple-timestepping-py">
<h3>simple_timestepping.py<a class="headerlink" href="#simple-timestepping-py" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Storage selection (SAS) functions: simple example</span>

<span class="sd">Runs the rSAS model for an example dataset with one outflow. A file containing </span>
<span class="sd">a steady-state transit time distribution is loaded, and used to construct an </span>
<span class="sd">equivalent storage seletion function.</span>

<span class="sd">This script uses the time-stepping algorithm (mode=&#39;time&#39;), and </span>
<span class="sd">calculates discharge concentrations progressively. This saves memory, but is not</span>
<span class="sd">advised if you want to run the model with the same rSAS parameters but different</span>
<span class="sd">concentration input timeseries.</span>

<span class="sd">The example dataset is the same as in lower_hafren_example.py, but the results here are not</span>
<span class="sd">intended to be realistic.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">rsas</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="c"># =====================================</span>
<span class="c"># Load and process the input timeseries</span>
<span class="c"># =====================================</span>
<span class="c"># Load the data</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">&#39;lower_hafren_data.csv&#39;</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c"># Uncomment the following line if you want to just run the first 2000 days</span>
<span class="c"># data = data[:2000]</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="c"># Calculate a (bogus) effective rainfall rate</span>
<span class="n">data</span><span class="p">[</span><span class="s">&#39;Peff water flux mm/day&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;Q water flux mm/day&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;P water flux mm/day&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;P water flux mm/day&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="c"># Calculate a (bogus) adjusted concentration</span>
<span class="n">data</span><span class="p">[</span><span class="s">&#39;Peff Cl mg/l&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;Q Cl mg/l&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;P Cl mg/l&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;P Cl mg/l&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="c"># =========================</span>
<span class="c"># Parameters needed by rsas</span>
<span class="c"># =========================</span>
<span class="c"># The concentration of discharge older than the start of observations is</span>
<span class="c"># assumed to be the long-term mean deposition rate divided by mean discharge</span>
<span class="n">C_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;Peff Cl mg/l&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;P Cl mg/l&#39;</span><span class="p">])</span><span class="o">/</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;Peff Cl mg/l&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="c"># =========================</span>
<span class="c"># Create the rsas functions</span>
<span class="c"># =========================</span>
<span class="n">Q_rSAS_fun_type</span> <span class="o">=</span> <span class="s">&#39;from_steady_state_TTD&#39;</span>
<span class="n">TT_CDF</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">&#39;example_steady_state_TTD.csv&#39;</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="s">&#39;P&#39;</span><span class="p">)</span>
<span class="n">Q_rSAS_fun_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">TT_CDF</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>
<span class="n">Q_rSAS_fun_parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">5.72</span> <span class="c"># steady-state flow rate</span>
<span class="n">Q_rSAS_fun_parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">TT_CDF</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">rSAS_fun_Q</span> <span class="o">=</span> <span class="n">rsas</span><span class="o">.</span><span class="n">create_function</span><span class="p">(</span><span class="n">Q_rSAS_fun_type</span><span class="p">,</span> <span class="n">Q_rSAS_fun_parameters</span><span class="p">)</span>
<span class="c"># =================</span>
<span class="c"># Initial condition</span>
<span class="c"># =================</span>
<span class="c"># Unknown total storage</span>
<span class="n">ST_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="c"># =============</span>
<span class="c"># Run the model</span>
<span class="c"># =============</span>
<span class="c"># Let&#39;s pull these out to make the inputs to rsas crystal clear</span>
<span class="n">Peff</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;Peff water flux mm/day&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
<span class="n">Q</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;Q water flux mm/day&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
<span class="n">C_in</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;Peff Cl mg/l&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
<span class="c"># Run it</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">rsas</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Peff</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">rSAS_fun_Q</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="n">ST_init</span><span class="o">=</span><span class="n">ST_init</span><span class="p">,</span> <span class="n">C_in</span><span class="o">=</span><span class="n">C_in</span><span class="p">,</span> <span class="n">C_old</span><span class="o">=</span><span class="n">C_old</span><span class="p">)</span>
<span class="c"># Plot the result</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;P Cl mg/l&#39;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s">&#39;0.7&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Load in&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;Q Cl mg/l&#39;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Obs load out&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">output</span><span class="p">[</span><span class="s">&#39;C_out&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Pred load out&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="lower-hafren-py">
<h3>lower_hafren.py<a class="headerlink" href="#lower-hafren-py" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Storage selection (SAS) functions: Lower Hafren example</span>

<span class="sd">Runs the rSAS model for the Lower Hafren stream to reproduce the results</span>
<span class="sd">presented in:</span>

<span class="sd">Harman, C. J. (2014), Time-variable transit time distributions and transport:</span>
<span class="sd">Theory and application to storage-dependent transport of chloride in a watershed,</span>
<span class="sd">Water Resour. Res., 51, doi:10.1002/2014WR015707.</span>

<span class="sd">The loaded dataset has already been gap-filled. The method to estimate the </span>
<span class="sd">evapotranspiration timeseries and to account for occult deposition of chloride</span>
<span class="sd">are included here though.</span>

<span class="sd">This script is identical to lower_hafren_example_timestepping.py, except that</span>
<span class="sd">the numerical scheme originally used in the paper (mode=&#39;age&#39;) is called,</span>
<span class="sd">rather than a new one (mode=&#39;time&#39;).</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">rsas</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="c"># =====================================</span>
<span class="c"># Load and process the input timeseries</span>
<span class="c"># =====================================</span>
<span class="c"># Load the data</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">&#39;lower_hafren_data.csv&#39;</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">parse_dates</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c"># Uncomment the following line if you want to just run the first 2000 days</span>
<span class="c"># data = data[:2000]</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="c"># Estimate ET from FAO reference evapotranspiration as ET = k_E * ETO, where</span>
<span class="c"># k_E is chosen to ensurelong-term mass balance.</span>
<span class="n">k_ET</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;P water flux mm/day&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;Q water flux mm/day&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span><span class="o">/</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;ET0 mm/day&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">data</span><span class="p">[</span><span class="s">&#39;ET water flux mm/day&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;ET0 mm/day&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">k_ET</span>
<span class="c"># The fraction of CL deposition from occult deposition (mist droplets) was</span>
<span class="c"># estimated from literature values and used to scale the timeseries values</span>
<span class="n">occult_fraction</span> <span class="o">=</span> <span class="mf">0.27</span>
<span class="n">data</span><span class="p">[</span><span class="s">&#39;P+occult Cl mg/l&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;P Cl mg/l&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">occult_fraction</span><span class="p">)</span>
<span class="c"># =========================</span>
<span class="c"># Parameters needed by rsas</span>
<span class="c"># =========================</span>
<span class="c"># The concentration of discharge older than the start of observations is</span>
<span class="c"># assumed to be the long-term mean deposition rate divided by mean discharge</span>
<span class="n">C_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;P+occult Cl mg/l&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;P water flux mm/day&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;Q water flux mm/day&#39;</span><span class="p">])</span>
<span class="c"># =========================</span>
<span class="c"># Create the rsas functions</span>
<span class="c"># =========================</span>
<span class="c"># Parameters for the rSAS function (see Harman [2015])</span>
<span class="c"># - Discharge</span>
<span class="n">Q_rSAS_fun_type</span> <span class="o">=</span> <span class="s">&#39;gamma&#39;</span>
<span class="n">lambda_Q</span> <span class="o">=</span> <span class="o">-</span><span class="mf">102.</span>
<span class="n">Q_alpha</span> <span class="o">=</span> <span class="mf">0.6856</span>
<span class="n">Q_dS_crit</span> <span class="o">=</span> <span class="mf">48.25</span>
<span class="n">S_Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">lambda_Q</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;S mm&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">Q_dS_crit</span><span class="p">))</span>
<span class="n">Q_rSAS_fun_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">S_Q</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">Q_alpha</span><span class="p">]</span>
<span class="n">rSAS_fun_Q</span> <span class="o">=</span> <span class="n">rsas</span><span class="o">.</span><span class="n">create_function</span><span class="p">(</span><span class="n">Q_rSAS_fun_type</span><span class="p">,</span> <span class="n">Q_rSAS_fun_parameters</span><span class="p">)</span>
<span class="c"># - ET</span>
<span class="n">ET_rSAS_fun_type</span> <span class="o">=</span> <span class="s">&#39;uniform&#39;</span>
<span class="n">S_ET</span> <span class="o">=</span> <span class="mf">398.</span>
<span class="n">ET_rSAS_fun_parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">S_ET</span> <span class="p">]</span>
<span class="n">rSAS_fun_ET</span> <span class="o">=</span> <span class="n">rsas</span><span class="o">.</span><span class="n">create_function</span><span class="p">(</span><span class="n">ET_rSAS_fun_type</span><span class="p">,</span> <span class="n">ET_rSAS_fun_parameters</span><span class="p">)</span>
<span class="c"># =================</span>
<span class="c"># Initial condition</span>
<span class="c"># =================</span>
<span class="c"># Unknown total storage</span>
<span class="n">ST_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="c"># =============</span>
<span class="c"># Run the model</span>
<span class="c"># =============</span>
<span class="c"># Let&#39;s pull these out to make the inputs to rsas crystal clear</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;P water flux mm/day&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
<span class="n">Q</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;Q water flux mm/day&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
<span class="n">ET</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;ET water flux mm/day&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
<span class="n">C_in</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;P+occult Cl mg/l&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
<span class="c"># Run it</span>
<span class="n">outputs</span> <span class="o">=</span> <span class="n">rsas</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="p">[</span><span class="n">Q</span><span class="p">,</span> <span class="n">ET</span><span class="p">],</span> <span class="p">[</span><span class="n">rSAS_fun_Q</span><span class="p">,</span> <span class="n">rSAS_fun_ET</span><span class="p">],</span> <span class="n">ST_init</span><span class="o">=</span><span class="n">ST_init</span><span class="p">,</span> 
                     <span class="n">mode</span><span class="o">=</span><span class="s">&#39;age&#39;</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">n_substeps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_iterations</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="c"># Let&#39;s pull these out to make the outputs from rsas crystal clear</span>
<span class="n">PQ</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="s">&#39;PQ&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="n">thetaQ</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="s">&#39;thetaQ&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="n">thetaS</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="s">&#39;thetaS&#39;</span><span class="p">]</span>
<span class="c"># =====================================================================</span>
<span class="c"># Convolve the transit time distributions with the input concentrations</span>
<span class="c"># =====================================================================</span>
<span class="c"># Use the estimated transit time distribution and input timeseries to estimate</span>
<span class="c"># the output timeseries</span>
<span class="n">C_out</span><span class="p">,</span> <span class="n">C_mod_raw</span><span class="p">,</span> <span class="n">observed_fraction</span> <span class="o">=</span> <span class="n">rsas</span><span class="o">.</span><span class="n">transport_with_evapoconcentration</span><span class="p">(</span><span class="n">PQ</span><span class="p">,</span> <span class="n">thetaQ</span><span class="p">,</span> <span class="n">thetaS</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;P+occult Cl mg/l&#39;</span><span class="p">],</span> <span class="n">C_old</span><span class="p">)</span>
<span class="n">data</span><span class="p">[</span><span class="s">&#39;Q Predicted Cl mg/l&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">C_out</span>
<span class="c"># Plot the result</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;Q Cl mg/l&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Observed&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s">&#39;Q Predicted Cl mg/l&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;Predicted&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="further-reading">
<h1>Further reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h1>
<p>The rSAS theory is described in:</p>
<p>Harman, C. J. (2014), Time-variable transit time distributions and transport:
Theory and application to storage-dependent transport of chloride in a watershed,
Water Resour. Res., 51, doi:10.1002/2014WR015707.</p>
<div class="section" id="module-rsas">
<span id="documentation-for-the-code"></span><h2>Documentation for the code<a class="headerlink" href="#module-rsas" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="rsas.solve">
<code class="descclassname">rsas.</code><code class="descname">solve</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rsas.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the rSAS model for given fluxes</p>
<dl class="docutils">
<dt>Args: </dt>
<dd><dl class="first last docutils">
<dt>J <span class="classifier-delimiter">:</span> <span class="classifier">n x 1 float64 ndarray</span></dt>
<dd>Timestep-averaged inflow timeseries</dd>
<dt>Q <span class="classifier-delimiter">:</span> <span class="classifier">n x 2 float64 ndarray or list of n x 1 float64 ndarray</span></dt>
<dd>Timestep-averaged outflow timeseries. Must have same units and length as J.
For multiple outflows, each column represents one outflow</dd>
<dt>rSAS_fun <span class="classifier-delimiter">:</span> <span class="classifier">rSASFunctionClass or list of rSASFunctionClass generated by rsas.create_function</span></dt>
<dd>The number of rSASFunctionClass in this list must be the same as the 
number of columns in Q if Q is an ndarray, or elements in Q if it is a list.</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>mode <span class="classifier-delimiter">:</span> <span class="classifier">&#8216;age&#8217; or &#8216;time&#8217; (default)</span></dt>
<dd><p class="first">Numerical solution step order. &#8216;mode&#8217; refers to which variable is in the
outer loop of the numerical solution</p>
<dl class="last docutils">
<dt><code class="docutils literal"><span class="pre">mode='age'</span></code></dt>
<dd>This is the original implementation used to generate the results in the paper.
It is slightly faster than the &#8216;time&#8217; implementation, but doesn&#8217;t have the
memory-saving &#8220;full_outputs=False&#8221; option. There is no option to calculate 
output concentration timeseries inline. The calculated transit time
distributions must convolved with an input concentration timeseries after the code has 
completed.</dd>
<dt><code class="docutils literal"><span class="pre">mode='time'</span></code></dt>
<dd>Slower, but easier to understand and build on than the &#8216;age&#8217; mode.
Memory savings come with the option to determine output concentrations
from a given input concentration progressively, and not retain the full
age-ranked storage and transit time distributions in memory (set
full_outputs=False to take advantage of this).</dd>
</dl>
</dd>
<dt>ST_init <span class="classifier-delimiter">:</span> <span class="classifier">m x 1 float64 ndarray</span></dt>
<dd>Initial condition for the age-ranked storage. The length of ST_init
determines the maximum age calculated. The first entry must be 0
(corresponding to zero age). To calculate transit time dsitributions up
to N timesteps in age, ST_init should have length m = M + 1. The default
initial condition is ST_init=np.zeros(len(J) + 1).</dd>
<dt>dt <span class="classifier-delimiter">:</span> <span class="classifier">float (default 1)</span></dt>
<dd>Timestep, assuming same units as J</dd>
<dt>n_substeps <span class="classifier-delimiter">:</span> <span class="classifier">int (default 1)</span></dt>
<dd>(mode=&#8217;age&#8217; only) If n_substeps&gt;1, the timesteps are subdivided to allow a more accurate
solution. Default is 1, which is also the value used in Harman (2015)</dd>
<dt>n_iterations <span class="classifier-delimiter">:</span> <span class="classifier">int (default 3)</span></dt>
<dd>Number of iterations to converge on a consistent solution. Convergence 
in Harman (2015) was very fast, and n_iterations=3 was adequate (also 
the default value here)</dd>
<dt>full_outputs <span class="classifier-delimiter">:</span> <span class="classifier">bool (default True)</span></dt>
<dd>Option to return the full state variables array ST the cumulative
transit time distributions PQ1, PQ2, and other variables</dd>
<dt>C_in <span class="classifier-delimiter">:</span> <span class="classifier">n x 1 float64 ndarray (default None)</span></dt>
<dd>Optional timeseries of inflow concentrations to convolved
with the computed transit time distribution for the first flux in Q</dd>
<dt>C_old <span class="classifier-delimiter">:</span> <span class="classifier">float (default None)</span></dt>
<dd>Optional concentration of the &#8216;unobserved fraction&#8217; of Q (from inflows 
prior to the start of the simulation) for correcting C_out. If ST_init is not given 
or set to all zeros, the unobserved fraction will be assumed to lie on the 
diagonal of the PQ matrix. Otherwise it will be assumed to be the bottom row.</dd>
<dt>evapoconcentration <span class="classifier-delimiter">:</span> <span class="classifier">bool (default False)</span></dt>
<dd>If True, it will be assumed that species in C_in are not removed 
by the second flux, and instead become increasingly concentrated in
storage.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>A dict with the following keys:</dt>
<dd><dl class="first last docutils">
<dt>&#8216;ST&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">numpy float64 2D array</span></dt>
<dd>Array of age-ranked storage for all ages and times. (full_outputs=True only)</dd>
<dt>&#8216;PQ&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">numpy float64 2D array</span></dt>
<dd>List of time-varying cumulative transit time distributions. (full_outputs=True only)</dd>
<dt>&#8216;Qout&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">numpy float64 2D array</span></dt>
<dd>List of age-based outflow timeseries. Useful for visualization. (full_outputs=True only)</dd>
<dt>&#8216;theta&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">numpy float64 2D array</span></dt>
<dd>List of partial partition functions for each outflux. Keeps track of the
fraction of inputs that leave by each flux. This is needed to do
transport with evapoconcentration. (full_outputs=True only)</dd>
<dt>&#8216;thetaS&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">numpy float64 2D array</span></dt>
<dd>Storage partial partition function fr each outflux. Keeps track of the
fraction of inputs that remain in storage. This is needed to do
transport with evapoconcentration. (full_outputs=True only)</dd>
<dt>&#8216;MassBalance&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">numpy float64 2D array</span></dt>
<dd>Should always be within tolerances of zero, unless something is very
wrong. (full_outputs=True only)</dd>
<dt>&#8216;C_out&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">list of numpy float64 1D array</span></dt>
<dd>If C_in is supplied, C_out is the timeseries of outflow concentration 
in Q1. (mode=&#8217;time&#8217; only)</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>For each of the arrays in the full outputs each row represents an age, and each
column is a timestep. For N timesteps and M ages, ST will have dimensions
(M+1) x (N+1), with the first row representing age T = 0 and the first
column derived from the initial condition.</p>
</dd></dl>

<dl class="function">
<dt id="rsas.create_function">
<code class="descclassname">rsas.</code><code class="descname">create_function</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#rsas.create_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize an rSAS function</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>rSAS_type <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>A string indicating the requested rSAS functional form.</dd>
<dt>params <span class="classifier-delimiter">:</span> <span class="classifier">n x k float64 ndarray</span></dt>
<dd>Parameters for the rSAS function. The number of columns and 
their meaning depends on which rSAS type is chosen. For all the rSAS 
functions implemented so far, each row corresponds with a timestep.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>rSAS_fun <span class="classifier-delimiter">:</span> <span class="classifier">rSASFunctionClass</span></dt>
<dd>An rSAS function of the chosen type</dd>
</dl>
</dd>
</dl>
<p>The created function object will have methods that vary between types. All
must have a constructor (&#8220;__init__&#8221;) and two methods cdf_all and cdf_i. See
the documentation for rSASFunctionClass for more information.</p>
<p>Available choices for rSAS_type, and a description of parameter array, are below.
These all take one parameter set (row) per timestep:</p>
<dl class="docutils">
<dt>&#8216;uniform&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">Uniform distribution over the range [a, b].</span></dt>
<dd><ul class="first last simple">
<li><code class="docutils literal"><span class="pre">Q_params[:,</span> <span class="pre">0]</span></code> = a</li>
<li><code class="docutils literal"><span class="pre">Q_params[:,</span> <span class="pre">1]</span></code> = b</li>
</ul>
</dd>
<dt>&#8216;gamma&#8217;: Gamma distribution</dt>
<dd><ul class="first last simple">
<li><code class="docutils literal"><span class="pre">Q_params[:,</span> <span class="pre">0]</span></code> = shift parameter</li>
<li><code class="docutils literal"><span class="pre">Q_params[:,</span> <span class="pre">1]</span></code> = scale parameter</li>
<li><code class="docutils literal"><span class="pre">Q_params[:,</span> <span class="pre">2]</span></code> = shape parameter</li>
</ul>
</dd>
<dt>&#8216;gamma_trunc&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">Gamma distribution, truncated at a maximum value</span></dt>
<dd><ul class="first last simple">
<li><code class="docutils literal"><span class="pre">Q_params[:,</span> <span class="pre">0]</span></code> = shift parameter</li>
<li><code class="docutils literal"><span class="pre">Q_params[:,</span> <span class="pre">1]</span></code> = scale parameter</li>
<li><code class="docutils literal"><span class="pre">Q_params[:,</span> <span class="pre">2]</span></code> = shape parameter</li>
<li><code class="docutils literal"><span class="pre">Q_params[:,</span> <span class="pre">3]</span></code> = maximum value</li>
</ul>
</dd>
<dt>&#8216;SS_invgauss&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">Produces analytical solution to the advection-dispersion equation</span></dt>
<dd><dl class="first last docutils">
<dt>(inverse Gaussian distribution) under steady-state flow.</dt>
<dd><ul class="first last simple">
<li><code class="docutils literal"><span class="pre">Q_params[:,</span> <span class="pre">0]</span></code> = scale parameter</li>
<li><code class="docutils literal"><span class="pre">Q_params[:,</span> <span class="pre">1]</span></code> = Peclet number</li>
</ul>
</dd>
</dl>
</dd>
<dt>&#8216;SS_mobileimmobile&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">Produces analytical solution to the advection-dispersion equation with</span></dt>
<dd><dl class="first last docutils">
<dt>linear mobile-immobile zone exchange under steady-state flow.</dt>
<dd><ul class="first last simple">
<li><code class="docutils literal"><span class="pre">Q_params[:,</span> <span class="pre">0]</span></code> = scale parameter</li>
<li><code class="docutils literal"><span class="pre">Q_params[:,</span> <span class="pre">1]</span></code> = Peclet number</li>
<li><code class="docutils literal"><span class="pre">Q_params[:,</span> <span class="pre">2]</span></code> = beta parameter</li>
</ul>
</dd>
</dl>
</dd>
<dt>&#8216;from_steady_state_TTD&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">rSAS function constructed to reproduce a given transit time distribution</span></dt>
<dd><dl class="first last docutils">
<dt>at steady flow. Assumes timestep is dt=1.</dt>
<dd><ul class="first last simple">
<li><code class="docutils literal"><span class="pre">Q_params[0,</span> <span class="pre">0]</span></code> = Steady flow rate</li>
<li><code class="docutils literal"><span class="pre">Q_params[1:,</span> <span class="pre">0]</span></code> = Steady-state transit time distribution, from T = dt.</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="rsas.transport">
<code class="descclassname">rsas.</code><code class="descname">transport</code><span class="sig-paren">(</span><em>PQ</em>, <em>C_in</em>, <em>C_old</em><span class="sig-paren">)</span><a class="headerlink" href="#rsas.transport" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a time-varying transit time distribution to an input concentration timseries</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>PQ <span class="classifier-delimiter">:</span> <span class="classifier">numpy float64 2D array, size N x N</span></dt>
<dd>The CDF of the backwards transit time distribution P_Q1(T,t)</dd>
<dt>C_in <span class="classifier-delimiter">:</span> <span class="classifier">numpy float64 1D array, length N.</span></dt>
<dd>Timestep-averaged inflow concentration.</dd>
<dt>C_old <span class="classifier-delimiter">:</span> <span class="classifier">numpy float64 1D array, length N.</span></dt>
<dd>Concentration to be assumed for portion of outflows older than initial
timestep</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>C_out <span class="classifier-delimiter">:</span> <span class="classifier">numpy float64 1D array, length N.</span></dt>
<dd>Timestep-averaged outflow concentration.</dd>
<dt>C_mod_raw <span class="classifier-delimiter">:</span> <span class="classifier">numpy float64 1D array, length N.</span></dt>
<dd>Timestep-averaged outflow concentration, prior to correction with C_old.</dd>
<dt>observed_fraction <span class="classifier-delimiter">:</span> <span class="classifier">numpy float64 1D array, length N.</span></dt>
<dd>Fraction of outflow older than the first timestep</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="rsas.transport_with_evapoconcentration">
<code class="descclassname">rsas.</code><code class="descname">transport_with_evapoconcentration</code><span class="sig-paren">(</span><em>PQ</em>, <em>thetaQ</em>, <em>thetaS</em>, <em>C_in</em>, <em>C_old</em>, <em>observed_fraction_on_diagonal=True</em><span class="sig-paren">)</span><a class="headerlink" href="#rsas.transport_with_evapoconcentration" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a time-varying transit time distribution to an input concentration timseries</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>PQ <span class="classifier-delimiter">:</span> <span class="classifier">numpy float64 2D array, size N+1 x N+1</span></dt>
<dd>The CDF of the backwards transit time distribution P_Q1(T,t)</dd>
<dt>thetaQ, thetaS <span class="classifier-delimiter">:</span> <span class="classifier">numpy float64 2D array, size N+1 x N+1</span></dt>
<dd>Partial partition functions for discharge and storage</dd>
<dt>C_in <span class="classifier-delimiter">:</span> <span class="classifier">numpy float64 1D array, length N.</span></dt>
<dd>Timestep-averaged inflow concentration.</dd>
<dt>C_old <span class="classifier-delimiter">:</span> <span class="classifier">numpy float64 1D array, length N.</span></dt>
<dd>Concentration to be assumed for portion of outflows older than initial
timestep</dd>
<dt>observed_fraction_on_diagonal <span class="classifier-delimiter">:</span> <span class="classifier">Boolean</span></dt>
<dd>Location of the observed fraction. &#8216;True&#8217; (default) assumes observed
fraction is on the diagonal of the PQ matrix. This is appropriate
if no initial condition for ST is given. Otherwise use &#8216;False&#8217; to 
use the oldest value of T for which PQ is given (i.e. the last row)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>C_out <span class="classifier-delimiter">:</span> <span class="classifier">numpy float64 1D array, length N.</span></dt>
<dd>Timestep-averaged outflow concentration.</dd>
<dt>C_mod_raw <span class="classifier-delimiter">:</span> <span class="classifier">numpy float64 1D array, length N.</span></dt>
<dd>Timestep-averaged outflow concentration, prior to correction with C_old.</dd>
<dt>observed_fraction <span class="classifier-delimiter">:</span> <span class="classifier">numpy float64 1D array, length N.</span></dt>
<dd>Fraction of outflow older than the first timestep</dd>
</dl>
</dd>
</dl>
</dd></dl>

<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference internal" href="py-modindex.html"><em>Module Index</em></a></li>
<li><a class="reference internal" href="search.html"><em>Search Page</em></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Documentation of the rsas library</a></li>
<li><a class="reference internal" href="#getting-started">Getting started</a><ul>
<li><a class="reference internal" href="#before-you-install">Before you install</a></li>
<li><a class="reference internal" href="#getting-rsas">Getting rsas</a></li>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#simple-timestepping-py">simple_timestepping.py</a></li>
<li><a class="reference internal" href="#lower-hafren-py">lower_hafren.py</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#further-reading">Further reading</a><ul>
<li><a class="reference internal" href="#module-rsas">Documentation for the code</a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">rsas 0.1.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Ciaran J. Harman.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3b2.
    </div>
  </body>
</html>